// Copyright 2017 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "google/longrunning/operations.proto";
import "google/devtools/source/v1/source_context.proto";

package grafeas.v1alpha1.api;
option go_package = "grafeas";

// Request to get a Occurrence.
message GetOccurrenceRequest {
    // The name of the occurrence in the form
    // "projects/{project_id}/occurrences/{occurrence_id}"
    string name = 1;
}

// Request to list occurrences.
message ListOccurrencesRequest {
    // This contains the projectId for example: projects/{project_id}
    string parent = 5;
    // The filter expression.
    string filter = 2;
    // Number of occurrences to return in the list.
    int32 page_size = 3;
    // Token to provide to skip to a particular spot in the list.
    string page_token = 4;
}

// Request to delete a occurrence
message DeleteOccurrenceRequest {
    // The name of the occurrence in the form
    // "projects/{project_id}/occurrences/{occurrence_id}"
    string name = 1;
}

// Request to insert a new occurrence
message CreateOccurrenceRequest {
    // This field contains the projectId for example: "projects/{project_id}"
    string parent = 3;
    // The occurrence to be inserted
    Occurrence occurrence = 2;
}

// Request to update an existing occurrence
message UpdateOccurrenceRequest {
    // The name of the occurrence.
    // Should be of the form "projects/{project_id}/occurrences/{occurrence_id}".
    string name = 1;
    // The updated occurrence.
    Occurrence occurrence = 2;
}

// Request to get a Note.
message GetNoteRequest {
    // The name of the note in the form
    // "providers/{provider_id}/notes/{note_id}"
    string name = 1;
}

// Request to get the note to which this occurrence is attached.
message GetOccurrenceNoteRequest {
    // The name of the occurrence in the form
    // "projects/{project_id}/occurrences/{occurrence_id}"
    string name = 1;
}

// Request to list notes.
message ListNotesRequest {
    // The name field will contain the projectId for example:
    // "providers/{provider_id}
    // @Deprecated
    string name = 1;
    // This field contains the projectId for example:
    // "project/{project_id}
    string parent = 5;
    // The filter expression.
    string filter = 2;
    // Number of notes to return in the list.
    int32 page_size = 3;
    // Token to provide to skip to a particular spot in the list.
    string page_token = 4;
}

// Request to delete a note
message DeleteNoteRequest {
    // The name of the note in the form
    // "providers/{provider_id}/notes/{note_id}"
    string name = 1;
}

// Request to insert a new note
message CreateNoteRequest {
    // The name of the project.
    // Should be of the form "providers/{provider_id}".
    // @Deprecated
    string name = 1;
    // This field contains the projectId for example:
    // "project/{project_id}
    string parent = 4;
    // The ID to use for this note.
    string note_id = 2;
    // The Note to be inserted
    Note note = 3;
}

// Request to update an existing note
message UpdateNoteRequest {
    // The name of the note.
    // Should be of the form "projects/{provider_id}/notes/{note_id}".
    string name = 1;
    // The updated note.
    Note note = 2;
}

// Request to list occurrences.
message ListNoteOccurrencesRequest {
    // The name field will contain the note name for example:
    //   "provider/{provider_id}/notes/{note_id}"
    string name = 1;
    // The filter expression.
    string filter = 2;
    // Number of notes to return in the list.
    int32 page_size = 3;
    // Token to provide to skip to a particular spot in the list.
    string page_token = 4;
}

// Response including listed occurrences for a note.
message ListNoteOccurrencesResponse {
    // Token to receive the next page of notes.
    string nextPageToken = 1;
    // The occurrences attached to the specified note.
    repeated Occurrence occurrences = 2;
}

// Response including listed notes.
message ListNotesResponse {
    // The next pagination token in the List response. It should be used as
    // page_token for the following request. An empty value means no more result.
    string nextPageToken = 1;
    // The occurrences requested
    repeated Note notes = 2;
}

// Response including listed occurrences.
message ListOccurrencesResponse {
    // The next pagination token in the List response. It should be used as
    // page_token for the following request. An empty value means no more results.
    string nextPageToken = 1;
    // The occurrences requested.
    repeated Occurrence occurrences = 2;
}

// Response including listed operations.
message ListOperationsResponse {
    // The next pagination token in the List response. It should be used as
    // page_token for the following request. An empty value means no more results.
    string nextPageToken = 1;
    // The operations requested.
    repeated google.longrunning.Operation operations = 2;
}

// Request for updating an existing operation
message UpdateOperationRequest {
    // The name of the Operation.
    // Should be of the form "projects/{provider_id}/operations/{operation_id}".
    string name = 1;
    // The operation to create.
    google.longrunning.Operation operation = 3;
}

// Request for creating an operation
message CreateOperationRequest {
    // The projectId that this operation should be created under.
    string parent = 1;
    // The ID to use for this operation.
    string operation_id = 2;
    // The operation to create.
    google.longrunning.Operation operation = 3;
}

// OperationMetadata can be used to provide additional information inside a google.longrunning.operation
message OperationMetadata {
    // Output only. The time this operation was created.
    google.protobuf.Timestamp create_time = 1;
    // Output only. The time that this operation was marked completed or failed.
    google.protobuf.Timestamp end_time = 2;
}

// Artifact describes a build product.
message Artifact {
    // Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
    // container.
    string checksum = 1;
    // Artifact ID, if any; for container images, this will be a URL by digest
    // like gcr.io/projectID/imagename@sha256:123456
    string id = 2;
    // Related artifact names. This may be the path to a binary or jar file, or in
    // the case of a container build, the name used to push the container image to
    // Google Container Registry, as presented to `docker push`. Note that a
    // single Artifact ID can have multiple names, for example if two tags are
    // applied to one image.
    repeated string names = 3;
}

// Note kind that represents a logical attestation "role" or "authority".  For
// example, an organization might have one AttestationAuthority for "QA" and one
// for "build".  This Note is intended to act strictly as a grouping mechanism
// for the attached Occurrences (Attestations).  This grouping mechanism also
// provides a security boundary, since IAM ACLs gate the ability for a principle
// to attach an Occurrence to a given Note.  It also provides a single point of
// lookup to find all attached Attestation Occurrences, even if they don't all
// live in the same project.
message AttestationAuthority {
    AttestationAuthorityHint hint = 1;

    message AttestationAuthorityHint {
        // The human readable name of this Attestation Authority, e.g. "qa".
        string human_readable_name = 1;
    }
    message Attestation {
        // The signature, generally over the `resource_url`, that verifies this
        // attestation.  The semantics of the signature veracity are ultimately
        // determined by the verification engine.
        oneof signature {
            PgpSignedAttestation pgp_signed_attestation = 1;
        }
    }
}

// Message encapsulating build provenance details
message BuildDetails {
    // The actual provenance
    BuildProvenance provenance = 1;
    // Serialized json representation of the provenance, used in generating the
    // BuildSignature in the corresponding Result. After verifying the signature,
    // provenance_bytes can be unmarshalled and compared to the provenance to
    // confirm that it is unchanged. A base64-encoded string representation of the
    // provenance bytes is used for the signature in order to interoperate with
    // openssl which expects this format for signature verification.
    // 
    // The serialized form is captured both to avoid ambiguity in how the
    // provenance is marshalled to json as well to prevent incompatibilities with
    // future changes.
    string provenance_bytes = 2;
}

// Provenance of a build. Contains all information needed to verify the full
// details about the build from source to completion.
message BuildProvenance {
    // Special options applied to this build. This is a catch-all field where
    // build providers can enter any desired additional details.
    map<string, string> build_options = 1;
    // Version string of the builder at the time this build was executed.
    string builder_version = 2;
    // Output of the build.
    repeated Artifact built_artifacts = 3;
    // Commands requested by the build.
    repeated Command commands = 4;
    // Time at which the build was created.
    string create_time = 5;
    // E-mail address of the user who initiated this build. Note that this was the
    // user's e-mail address at the time the build was initiated; this address may
    // not represent the same end-user for all time.
    string creator = 6;
    // Time at which execution of the build was finished.
    string finish_time = 7;
    // Unique identifier of the build.
    string id = 8;
    // Google Cloud Storage bucket where logs were written.
    string logs_bucket = 9;
    // ID of the project.
    string project_id = 10;
    // Numerical ID of the project.
    string project_num = 11;
    // Details of the Source input to the build.
    Source source_provenance = 12;
    // Time at which execution of the build was started.
    string start_time = 13;
    // Trigger identifier if the build was triggered automatically; empty if not.
    string trigger_id = 14;
}

// Message encapsulating signature of the verified build
message BuildSignature {
    // An ID for the key used to sign.  This could be either an ID for the key
    // stored in `public_key` (e.g., the ID or fingerprint for a PGP key, or the
    // CN for a cert), or a reference to an external key (e.g., a reference to a
    // key in Cloud KMS).
    string key_id = 1;
    // The type of the key, either stored in `public_key` or referenced in
    // `key_id`
    enum KeyType {
        UNSET = 0;
        PGP_ASCII_ARMORED = 1;
        PKIX_PEM = 2;
    }
    KeyType key_type = 2;
    // Public key of the builder which can be used to verify that related
    // Findings are valid and unchanged.  If `key_type` is empty this defaults
    // to PEM encoded public keys.
    // 
    // This field may be empty if `key_id` references an external key.
    // 
    // For Cloud Container Builder based signatures this is a PEM encoded public
    // key. To verify the Cloud Container Builder signature, place the contents of
    // this field into a file (public.pem). The signature field is base64-decoded
    // into its binary representation in signature.bin, and the provenance bytes
    // from BuildDetails are base64-decoded into a binary representation in
    // signed.bin. OpenSSL can then verify the signature:
    // `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
    string public_key = 3;
    // Signature of the related BuildProvenance, encoded in a base64 string.
    string signature = 4;
}

// Note holding the version of the provider's builder and the signature of
// the provenance message in linked BuildDetails.
message BuildType {
    // Version of the builder which produced this Note.
    string builder_version = 1;
    // Signature of the build in Occurrences pointing to the Note containing this
    // BuilderDetails.
    BuildSignature signature = 2;
}

// Command describes a step performed as part of the build pipeline.
message Command {
    // Command-line arguments used when executing this Command.
    repeated string args = 1;
    // Working directory (relative to project source root) used when running
    // this Command.
    string dir = 2;
    // Environment variables set before running this Command.
    repeated string env = 3;
    // Optional unique identifier for this Command, used in wait_for to reference
    // this Command as a dependency.
    string id = 4;
    // Name of the command, as presented on the command line, or if the command is
    // packaged as a Docker container, as presented to `docker pull`.
    string name = 5;
    // The ID(s) of the Command(s) that this Command depends on.
    repeated string wait_for = 6;
}

// An artifact that can be deployed in some runtime.
message Deployable {
    // Resource URI for the artifact being deployed.
    repeated string resource_uri = 1;

    // The period during which some deployable was active in a runtime.
    message Deployment {
        // Address of the runtime element hosting this deployment.
        string address = 1;
        // Configuration used to create this deployment.
        map<string, string> config = 2;
        // Beginning of the lifetime of this deployment.
        string deploy_time = 3;
        // End of the lifetime of this deployment.
        string undeploy_time = 4;
        // Identity of the user that triggered this deployment.
        string user_email = 5;
    }
}

// DockerImage holds types defining base image notes
// and derived image occurrences.
message DockerImage {
    // Instructions from dockerfile
    message Layer {
        // The recovered arguments to the Dockerfile directive.
        string arguments = 1;
        // The recovered Dockerfile directive used to construct this layer.
        enum Directive {
            UNKNOWN_DIRECTIVE = 0;
            MAINTAINER = 1;
            RUN = 2;
            CMD = 3;
            LABEL = 4;
            EXPOSE = 5;
            ENV = 6;
            ADD = 7;
            COPY = 8;
            ENTRYPOINT = 9;
            VOLUME = 10;
            USER = 11;
            WORKDIR = 12;
            ARG = 13;
            ONBUILD = 14;
            STOPSIGNAL = 15;
            HEALTHCHECK = 16;
            SHELL = 17;
        }
        Directive directive = 2;
    }

    // A set of properties that uniquely identify a given Docker image.
    message Fingerprint {
        // The layer-id of the final layer in the Docker image’s v1
        // representation.
        // This field can be used as a filter in list requests.
        string v1_name = 1;
        // The ordered list of v2 blobs that represent a given image.
        repeated string v2_blob = 2;
        // The name of the image’s v2 blobs computed via:
        //   [bottom] := v2_blobbottom := sha256(v2_blob[N] + “ ” + v2_name[N+1])
        // Only the name of the final blob is kept.
        // This field can be used as a filter in list requests.
        // @OutputOnly
        string v2_name = 3;
    }

    // Basis describes the base image portion (Note) of the DockerImage
    // relationship.  Linked occurrences are derived from this or an
    // equivalent image via:
    //   FROM <Basis.resource_url>
    // Or an equivalent reference, e.g. a tag of the resource_url.
    message Basis {
        // The fingerprint of the base image
        Fingerprint fingerprint = 1;
        // The resource_url for the resource representing the basis of
        // associated occurrence images.
        string resource_url = 2;
    }

    // Derived describes the derived image portion (Occurrence) of the
    // DockerImage relationship.  This image would be produced from a Dockerfile
    // with FROM <DockerImage.Basis in attached Note>.
    message Derived {
        // This contains the base image url for the derived image Occurrence
        // @OutputOnly
        string base_resource_url = 1;
        // The number of layers by which this image differs from
        // the associated image basis.
        // @OutputOnly
        uint32 distance = 2;
        // The fingerprint of the derived image
        Fingerprint fingerprint = 3;
        // This contains layer-specific metadata, if populated it
        // has length “distance” and is ordered with [distance] being the
        // layer immediately following the base image and [1]
        // being the final layer.
        repeated Layer layer_info = 4;
    }
}

// Note that indicates a type of analysis and exists in a provider project to
// indicate the status of an analysis on a resource. Absence of an occurrence
// linked to this note for a resource indicates that analysis hasn't started.
message Discovery {
    // The kind of analysis that is handled by this discovery.
    Note.Kind analysis_kind = 1;

    message Discovered {
        // An operation that indicates the status of the current scan.
        // @OutputOnly
        google.longrunning.Operation operation = 1;
    }
}

// Container message for hashes of byte content of files, used in Source
// messages to verify integrity of source input to the build.
message FileHashes {
    // Collection of file hashes.
    repeated Hash file_hash = 1;
}

// Container message for hash values.
message Hash {
    // The type of hash that was performed.
    enum Type {
        NONE = 0;
        SHA256 = 1;
        MD5 = 2;
    }
    Type type = 1;
    // The hash value.
    string value = 2;
}


// Note provides a detailed description of a note using information
// from the provider of the note.
message Note {
    // The name of the note in the form
    // "providers/{provider_id}/notes/{note_id}"
    string name = 1;

    // A one sentence description of this note
    string short_description = 3;
    // A detailed description of this note
    string long_description = 4;

    // This must be 1:1 with members of our oneofs, it can be used for filtering
    // Note and Occurrence on their kind.
    enum Kind {
        // Unknown
        KIND_UNSPECIFIED = 0;
        // The note and occurrence represent a package vulnerability.
        PACKAGE_VULNERABILITY = 1;
        // The note and occurrence assert build provenance.
        BUILD_DETAILS = 2;
        // This represents an image basis relationship.
        IMAGE_BASIS = 3;
        // This represents a package installed via a package manager.
        PACKAGE_MANAGER = 4;
        // The note and occurrence track deployment events.
        DEPLOYABLE = 5;
        // The note and occurrence track the initial discovery status of a resource.
        DISCOVERY = 6;
        // This represents a logical "role" that can attest to artifacts.
        ATTESTATION_AUTHORITY = 7;
    }

    // Output only. This explicitly denotes which kind of note is specified. This
    // field can be used as a filter in list requests.
    Note.Kind kind = 9;

    // The type of note.
    oneof note_type {
        // A package vulnerability type of note.
        VulnerabilityType vulnerability_type = 6;
        // Build provenance type for a verifiable build.
        BuildType build_type = 8;
        // A note describing a base image.
        DockerImage.Basis base_image = 13;
        // A note describing a package hosted by various package managers.
        PackageManager.Package package = 14;
        // A note describing something that can be deployed.
        Deployable deployable = 17;
        // A note describing a provider/analysis type.
        Discovery discovery = 18;
        // A note describing an attestation role.
        AttestationAuthority attestation_authority = 19;
    }
    // Urls associated with this note
    repeated RelatedUrl related_url = 7;

    // Metadata for any related url information
    message RelatedUrl {
        // Specific url to associate with the note
        string url = 1;
        // Label to describe usage of the url
        string label = 2;
    }

    // Time of expiration for this note, null if note currently does not expire.
    google.protobuf.Timestamp expiration_time = 10;

    // Output only. The time this note was created. This field can be used as a
    // filter in list requests.
    google.protobuf.Timestamp create_time = 11;

    // Output only. The time this note was last updated. This field can be used as
    // a filter in list requests.
    google.protobuf.Timestamp update_time = 12;

    // The name of the operation that created this note.
    string operation_name = 15;
}


// Occurrence includes information about analysis occurrences for an image.
message Occurrence {
    // Output only. The name of the occurrence in the form
    // "projects/{project_id}/occurrences/{occurrence_id}"
    string name = 1;

    // The unique url of the image or container for which the occurrence applies.
    // Example: https://gcr.io/project/image@sha256:foo
    // This field can be used as a filter in list requests.
    string resource_url = 2;

    // An analysis note associated with this image, in the form
    // "providers/{provider_id}/notes/{note_id}"
    // This field can be used as a filter in list requests.
    string note_name = 3;

    // Output only. This explicitly denotes which of the occurrence details is
    // specified. This field can be used as a filter in list requests.
    Note.Kind kind = 6;

    // Describes the details of the vulnerability note found in this resource.
    oneof details {
        // Details of a security vulnerability note.
        VulnerabilityType.VulnerabilityDetails vulnerability_details = 8;
        // Build details for a verifiable build.
        BuildDetails build_details = 7;
        // Describes how this resource derives from the basis
        // in the associated note.
        DockerImage.Derived derived_image = 11;
        // Describes the installation of a package on the linked resource.
        PackageManager.Installation installation = 12;
        // Describes the deployment of an artifact on a runtime.
        Deployable.Deployment deployment = 14;
        // Describes the initial scan status for this resource.
        Discovery.Discovered discovered = 15;
        // Describes an attestation of an artifact.
        AttestationAuthority.Attestation attestation = 16;
    }

    // A description of actions that can be taken to remedy the note
    string remediation = 5;

    // Output only. The time this occurrence was created.
    google.protobuf.Timestamp create_time = 9;

    // Output only. The time this occurrence was last updated.
    google.protobuf.Timestamp update_time = 10;

    // The name of the operation that created this note.
    string operation_name = 13;
}

// PackageManager provides metadata about available / installed packages.
message PackageManager {
    // This represents a particular package that is distributed over
    // various channels.
    // e.g. glibc (aka libc6) is distributed by many, at various versions.
    message Package {
        // The various channels by which a package is distributed.
        repeated Distribution distribution = 1;
        // The name of the package.
        string name = 2;
    }

    // This represents a particular channel of distribution for a given package.
    // e.g. Debian's jessie-backports dpkg mirror
    message Distribution {
        // The CPU architecture for which packages in this distribution
        // channel were built
        enum Architecture {
            UNKNOWN = 0;
            X86 = 1;
            X64 = 2;
        }
        Architecture architecture = 1;
        // The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
        // denoting the package manager version distributing a package.
        string cpe_uri = 2;
        // The distribution channel-specific description of this package.
        string description = 3;
        // The latest available version of this package in
        // this distribution channel.
        Version latest_version = 4;
        // A freeform string denoting the maintainer of this package.
        string maintainer = 5;
        // The distribution channel-specific homepage for this package.
        string url = 6;
    }

    // Version contains structured information about the version of the package.
    // For a discussion of this in Debian/Ubuntu:
    // http://serverfault.com/questions/604541/debian-packages-version-convention
    // For a discussion of this in Redhat/Fedora/Centos:
    // http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
    message Version {
        // Used to correct mistakes in the version numbering scheme.
        int32 epoch = 1;
        // The main part of the version name.
        string name = 2;
        // The iteration of the package build from the above version.
        string revision = 3;

        // Whether this is an ordinary package version or a
        // sentinel MIN/MAX version.
        enum VersionKind {
            // A standard package version, defined by the other fields.
            NORMAL = 0;
            // A special version representing negative infinity,
            // other fields are ignored.
            MINIMUM = 1;
            // A special version representing positive infinity,
            // other fields are ignored.
            MAXIMUM = 2;
        };

        // Distinguish between sentinel MIN/MAX versions and normal versions.
        // If kind is not NORMAL, then the other fields are ignored.
        VersionKind kind = 5;
    }

    // An occurrence of a particular package installation found within a
    // system's filesystem.
    // e.g. glibc was found in /var/lib/dpkg/status
    message Location {
        // The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
        // denoting the package manager version distributing a package.
        string cpe_uri = 1;
        // The path from which we gathered that this package/version is installed.
        string path = 2;
        // The version installed at this location.
        VulnerabilityType.Version version = 3;
    }

    // This represents how a particular software package may be installed on
    // a system.
    message Installation {

        // The name of the installed package.
        // @OutputOnly
        string name = 1;

        // All of the places within the filesystem versions of this package
        // have been found.
        repeated Location location = 2;
    }
}



// An attestation wrapper with a PGP-compatible signature.
// This message only supports ATTACHED signatures, where the payload that is
// signed is included alongside the signature itself in the same file.
message PgpSignedAttestation {
    // The raw content of the signature, as output by gpg or equivalent.  Since
    // this message only supports attached signatures, the payload that was signed
    // must be attached. While the signature format supported is dependent on the
    // verification implementation, currently only ASCII-armored (`--armor` to
    // gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are
    // supported.
    // Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will
    // create the signature content expected in this field in `signature.gpg` for
    // the `payload.json` attestation payload.
    string signature = 1;

    // Type (e.g. schema) of the attestation payload that was signed.
    enum ContentType {
        // ContentType is not set.
        CONTENT_TYPE_UNSPECIFIED = 0;
        // Atomic format attestation signature. See
        // https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
        // The payload extracted from `signature` is a JSON blob conforming to the
        // linked schema.
        SIMPLE_SIGNING_JSON = 1;
    }

    // Type (e.g. schema) of the attestation payload that was signed.
    // The verifier must ensure that the provided type is one that the verifier
    // supports, and that the attestation payload is a valid instantiation of that
    // type (e.g. by validating a JSON schema).
    ContentType content_type = 3;

    // This field is used by verifiers to select the public key used to validate
    // the signature.  Note that the policy of the verifier ultimately determines
    // which public keys verify a signature based on the context of the
    // verification.  There is no guarantee validation will succeed if the
    // verifier has no key matching this ID, even if it has a key under a
    // different ID that would verify the signature. Note that this ID should also
    // be present in the signature content above, but that is not expected to be
    // used by the verifier.
    oneof key_id {
        // The ID of the key, as output by `gpg --list-keys`.  This should be 8
        // hexidecimal digits, capitalized.  e.g.
        // $ gpg --list-keys pub
        // 2048R/A663AEEA 2017-08-01 uid                  Fake Name
        // <example-attesting-user@google.com>
        // In the above example, the `key_id` is "A663AEEA".
        // Note that in practice this ID is the last 64 bits of the key fingerprint.
        string pgp_key_id = 2;
    }
}

// Source describes the location of the source used for the build.
message Source {
    // Source location information.
    oneof source {
        // If provided, get the source from this location in in Google Cloud
        // Storage.
        // (== deprecation_description Source code in Google Cloud Stroage is
        // not supported. For input binary artifact locations, use
        // artifact_storage_source instead. ==)
        StorageSource storage_source = 1 [deprecated = true];

        // If provided, get source from this location in a Cloud Repo.
        // (== deprecation_description This field has been deprecated. Use
        // source_context, instead. ==)
        RepoSource repo_source = 2 [deprecated = true];
    }
    // If provided, the input binary artifacts for the build came from this
    // location.
    StorageSource artifact_storage_source = 4;

    // If provided, the source code used for the build came from this location.
    google.devtools.source.v1.ExtendedSourceContext source_context = 5;

    // If provided, some of the source code used for the build may be found in
    // these locations, in the case where the source repository had multiple
    // remotes or submodules. This list will not include the context specified in
    // the source_context field.
    repeated google.devtools.source.v1.ExtendedSourceContext
    additional_source_contexts = 6;

    // Hash(es) of the build source, which can be used to verify that the original
    // source integrity was maintained in the build.
    //
    // The keys to this map are file paths used as build source and the values
    // contain the hash values for those files.
    //
    // If the build source came in a single package such as a gzipped tarfile
    // (.tar.gz), the FileHash will be for the single path to that file.
    map<string, FileHashes> file_hashes = 3;
}

// RepoSource describes the location of the source in a Google Cloud Source
// Repository.
message RepoSource {
    // ID of the project that owns the repo.
    string project_id = 1;

    // Name of the repo.
    string repo_name = 2;

    // A revision within the source repository must be specified in
    // one of these ways.
    oneof revision {
        // Name of the branch to build.
        string branch_name = 3;

        //  Name of the tag to build.
        string tag_name = 4;

        // Explicit commit SHA to build.
        string commit_sha = 5;
    }
}

// StorageSource describes the location of the source in an archive file in
// Google Cloud Storage.
message StorageSource {
    // Google Cloud Storage bucket containing source (see [Bucket Name
    // Requirements]
    // (https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    string bucket = 1;
    // Google Cloud Storage generation for the object.
    string generation = 2;
    // Google Cloud Storage object containing source.
    string object = 3;
}

// VulnerabilityType provides metadata about a security vulnerability.
message VulnerabilityType {
    // Note provider-assigned severity/impact ranking
    enum Severity {
        SEVERITY_UNSPECIFIED = 0;  // Unknown Impact
        MINIMAL = 1;   // Minimal Impact
        LOW = 2;       // Low Impact
        MEDIUM = 3;    // Medium Impact
        HIGH = 4;      // High Impact
        CRITICAL = 5;  // Critical Impact
    }

    // The CVSS score for this Vulnerability.
    float cvss_score = 2;

    // Note provider assigned impact of the vulnerability
    Severity severity = 3;

    // All information about the package to specifically identify this
    // vulnerability. One entry per (version range and cpe_uri) the
    // package vulnerability has manifested in.
    repeated Detail details = 4;

    // Version contains structured information about the version of the package.
    // For a discussion of this in Debian/Ubuntu:
    // http://serverfault.com/questions/604541/debian-packages-version-convention
    // For a discussion of this in Redhat/Fedora/Centos:
    // http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
    message Version {
        // Used to correct mistakes in the version numbering scheme.
        int32 epoch = 1;
        // The main part of the version name.
        string name = 2;
        // The iteration of the package build from the above version.
        string revision = 3;

        // Whether this is an ordinary package version or a
        // sentinel MIN/MAX version.
        enum VersionKind {
            // A standard package version, defined by the other fields.
            NORMAL = 0;
            // A special version representing negative infinity,
            // other fields are ignored.
            MINIMUM = 1;
            // A special version representing positive infinity,
            // other fields are ignored.
            MAXIMUM = 2;
        };

        // Distinguish between sentinel MIN/MAX versions and normal versions.
        // If kind is not NORMAL, then the other fields are ignored.
        VersionKind kind = 5;
    }

    // Identifies all occurences of this vulnerability in the package for a
    // specific distro/location
    // For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
    message Detail {
        // The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in
        // which the vulnerability manifests.  Examples include distro or storage
        // location for vulnerable jar.
        // This field can be used as a filter in list requests.
        string cpe_uri = 1;

        // The name of the package where the vulnerability was found.
        // This field can be used as a filter in list requests.
        string package = 8;

        // The min version of the package in which the vulnerability exists.
        Version min_affected_version = 6;

        // The max version of the package in which the vulnerability exists.
        // This field can be used as a filter in list requests.
        Version max_affected_version = 7;

        // The severity (eg: distro assigned severity) for this vulnerability.
        string severity_name = 4;

        // A vendor-specific description of this note.
        string description = 9;

        // The fix for this specific package version.
        VulnerabilityLocation fixed_location = 5;

        // The type of package; whether native or non native(ruby gems,
        // node.js packages etc)
        string package_type = 10;
    }

    // Used by Occurrence to point to where the vulnerability exists and how
    // to fix it.
    message VulnerabilityDetails {

        // The type of package; whether native or non native(ruby gems,
        // node.js packages etc)
        string type = 3;

        // The note provider assigned Severity of the vulnerability.
        // @OutputOnly
        Severity severity = 4;

        // The CVSS score of this vulnerability. CVSS score is on a scale of 0-10
        // where 0 indicates low severity and 10 indicates high severity.
        // @OutputOnly
        float cvss_score = 5;

        // The set of affected locations and their fixes (if available) within
        // the associated resource.
        repeated PackageIssue package_issue = 6;
    }

    // This message wraps a location affected by a vulnerability and its
    // associated fix (if one is available).
    message PackageIssue {
        // The location of the vulnerability.
        VulnerabilityLocation affected_location = 1;

        // The location of the available fix for vulnerability.
        VulnerabilityLocation fixed_location = 2;

        // The severity (eg: distro assigned severity) for this vulnerability.
        string severity_name = 3;
    }

    // The location of the vulnerability
    message VulnerabilityLocation {
        // The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/)
        // format. Examples include distro or storage location for vulnerable jar.
        // This field can be used as a filter in list requests.
        string cpe_uri = 1;

        // The package being described.
        string package = 2;

        // The version of the package being described.
        // This field can be used as a filter in list requests.
        Version version = 4;
    }
}

service Grafeas {
    // Returns the requested occurrence.
    rpc GetOccurrence(GetOccurrenceRequest) returns (Occurrence) {
        option (google.api.http) = {
      get: "/v1alpha1/{name=projects/*/occurrences/*}"
    };
    };

    // Lists active occurrences for a given project/Digest.
    rpc ListOccurrences(ListOccurrencesRequest)
    returns (ListOccurrencesResponse) {
        option (google.api.http) = {
      get: "/v1alpha1/{parent=projects/*}/occurrences"
    };
    };
    // Deletes the given occurrence from the system.
    rpc DeleteOccurrence(DeleteOccurrenceRequest)
    returns (google.protobuf.Empty) {
        option (google.api.http) = {
      delete: "/v1alpha1/{name=projects/*/occurrences/*}"
    };
    };

    // Creates a new occurrence.
    rpc CreateOccurrence(CreateOccurrenceRequest) returns (Occurrence) {
        option (google.api.http) = {
      post: "/v1alpha1/{parent=projects/*}/occurrences"
      body: "occurrence"
    };
    };

    // Updates an existing occurrence.
    rpc UpdateOccurrence(UpdateOccurrenceRequest) returns (Occurrence) {
        option (google.api.http) = {
      patch: "/v1alpha1/{name=projects/*/occurrences/*}"
      body: "occurrence"
    };
    };

    // Gets the note that this occurrence is attached to.
    rpc GetOccurrenceNote(GetOccurrenceNoteRequest) returns (Note) {
        option (google.api.http) = {
      get: "/v1alpha1/{name=projects/*/occurrences/*}/notes"
    };
    };

    // Returns the requested occurrence
    rpc GetNote(GetNoteRequest) returns (Note) {
        option (google.api.http) = {
      get: "/v1alpha1/{name=projects/*/notes/*}"
    };
    };

    // Lists all notes for a given project.
    rpc ListNotes(ListNotesRequest) returns (ListNotesResponse) {
        option (google.api.http) = {
      get: "/v1alpha1/{parent=projects/*}/notes"
    };
    };

    // Deletes the given note from the system.
    rpc DeleteNote(DeleteNoteRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
      delete: "/v1alpha1/{name=projects/*/notes/*}"
    };
    };

    // Creates a new note.
    rpc CreateNote(CreateNoteRequest) returns (Note) {
        option (google.api.http) = {
      post: "/v1alpha1/{parent=projects/*}/notes"
      body: "note"
    };
    };

    // Updates an existing note.
    rpc UpdateNote(UpdateNoteRequest) returns (Note) {
        option (google.api.http) = {
      patch: "/v1alpha1/{name=projects/*/notes/*}"
      body: "note"
    };
    };

    // Lists the names of occurrences linked to a particular note.
    rpc ListNoteOccurrences(ListNoteOccurrencesRequest)
    returns (ListNoteOccurrencesResponse) {
        option (google.api.http) = {
      get: "/v1alpha1/{name=projects/*/notes/*}/occurrences"
    };
    };

    // Creates a new operation
    rpc CreateOperation(CreateOperationRequest)
    returns (google.longrunning.Operation) {
        option (google.api.http) = {
      post: "/v1alpha1/{parent=projects/*}/operations"
      body: "*"
    };
    };

    // Updates an existing operation returns an error if operation
    //  does not exist. The only valid operations are to update mark the done bit
    // change the result.
    rpc UpdateOperation(UpdateOperationRequest)
    returns (google.longrunning.Operation) {
        option (google.api.http) = {
      patch: "/v1alpha1/{name=projects/*/operations/*}"
      body: "*"
    };
    };

}
